// Generated by LiveScript 1.2.0
var typeCheck, ref$, keys, find, Defs, Defn, init, defn, toString$ = {}.toString, slice$ = [].slice;
typeCheck = require('type-check').typeCheck;
ref$ = require('prelude-ls'), keys = ref$.keys, find = ref$.find;
function ensureTuple(signature){
  signature == null && (signature = '');
  return signature.replace(/^([^(].*)/, "($1)");
}
Defs = (function(){
  Defs.displayName = 'Defs';
  var prototype = Defs.prototype, constructor = Defs;
  function Defs(){
    this.fns = {};
  }
  Object.defineProperty(prototype, 'signatures', {
    get: function(){
      return keys(this.fns);
    },
    configurable: true,
    enumerable: true
  });
  prototype.add = function(){
    switch (toString$.call(arguments[0]).slice(8, -1)) {
    case 'Function':
      return this.addDefault(arguments[0]);
    case 'String':
      return this.addOne(arguments[0], arguments[1]);
    case 'Object':
      return this.addMore(arguments[0]);
    }
  };
  prototype.addDefault = function(fn){
    return this.fns['(*)'] = fn;
  };
  prototype.addOne = function(sig, fn){
    return this.fns[ensureTuple(sig)] = fn;
  };
  prototype.addMore = function(map){
    var sig, fn, results$ = [];
    for (sig in map) {
      fn = map[sig];
      results$.push(this.addOne(sig, fn));
    }
    return results$;
  };
  prototype.get = function(sig){
    return this.fns[ensureTuple(sig)];
  };
  prototype.contains = function(sig){
    return this.get(sig) != null;
  };
  prototype.throwUnimplemented = function(){
    throw new Error("Unimplemented: fn requires one of " + this.signatures);
  };
  prototype.signatureOf = function(args){
    return find(partialize$.apply(this, [typeCheck, [void 8, args], [0]]))(
    this.signatures);
  };
  prototype.getImplFor = function(args){
    return this.get(this.signatureOf(args)) || this.throwUnimplemented();
  };
  prototype.apply = function(obj, args){
    return this.getImplFor(args).apply(obj, args);
  };
  return Defs;
}());
Defn = (function(){
  Defn.displayName = 'Defn';
  var prototype = Defn.prototype, constructor = Defn;
  function Defn(){
    this.__defs__ = new Defs;
  }
  prototype.signatures = function(){
    return this.__defs__.signatures;
  };
  prototype.hasSignature = function(it){
    return this.__defs__.contains(it);
  };
  prototype.canCall = function(){
    var args;
    args = slice$.call(arguments);
    return this.__defs__.signatureOf(args) != null;
  };
  prototype.define = function(){
    this.__defs__.add(arguments[0], arguments[1]);
    return this;
  };
  prototype.apply = function(obj, args){
    return this.__defs__.apply(obj, args);
  };
  prototype.call = function(obj){
    var args;
    args = slice$.call(arguments, 1);
    return this.__defs__.apply(obj, args);
  };
  return Defn;
}());
init = function(){
  var mainFn;
  mainFn = function(){
    var args;
    args = slice$.call(arguments);
    return mainFn.apply(this, args);
  };
  return importAll$(mainFn, new Defn);
};
defn = function(){
  var args, fn;
  args = slice$.call(arguments);
  fn = init();
  return fn.define.apply(fn, args);
};
defn.init = init;
module.exports = defn;
function partialize$(f, args, where){
  var context = this;
  return function(){
    var params = slice$.call(arguments), i,
        len = params.length, wlen = where.length,
        ta = args ? args.concat() : [], tw = where ? where.concat() : [];
    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
    return len < wlen && len ?
      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
  };
}
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}